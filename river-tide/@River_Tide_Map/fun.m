% Mon  2 Oct 12:27:30 CEST 2017
%% compute river tide for a scenario with specific boundary conditions and store it in the hash,
%% or retrive the scenario, if it was already computed
function [out, key, obj] = fun(obj,Xi,  ...
		... % Q0, ...
		wfun, cdfun, zbfun, ... %	%W0,S0, ...
		... % z1_downstream,cd
		... % cd,zb_downstream,
		omega, ...
		bc0l_var, bc0l_val, bc0l_p, ...
		bc0r_var, bc0r_val, bc0r_p, ...
		bcl_var, bcl_val, bcl_p, bcl_q, ...
		bcr_var, bcr_val, bcr_p, bcr_q, ...
		bc2l_var, bc2l_val, bc2l_p, bc2l_q, ...
		bc2r_var, bc2r_val, bc2r_p, bc2r_q, ...
		opt)
	if (nargin()<10)
		opt = [];
	end
	if (isempty(obj.rt))
		obj.init();
	end
%	if (~isfield(opt,'model_str'))
%		opt.model_str = 'wave';
%	end
	g   = Constant.g;
	% C   = sqrt(g/cd);
	Xi  = Xi{1};
	L   = Xi(2)-Xi(1);
	wfun = wfun{1};
	cdfun = cdfun{1};
	zbfun = zbfun{1};
	
	if (~isempty(bc2l_var))
		bc2l = {bc2l_var{1}, ...
			bc2l_val{1}, ...
			bc2l_p{1}(1), ...
			bc2l_p{1}(2), ...
			bc2l_q{1}(1), ...
			bc2l_q{1}(2)};
	else
		bc2l = repmat({{}},6,1);
	end
	if (~isempty(bc2r_var))
		bc2r = {bc2r_var{1}, ...
			bc2r_val{1}, ...
			bc2r_p{1}(1), ...
			bc2r_p{1}(2), ...
			bc2r_q{1}(1), ...
			bc2r_q{1}(2)};
	else
		bc2r = repmat({{}},6,1);
	end
 
	key = obj.key(...	
			opt.model_str, ...
			func2str(opt.solver), ...
			func2str(zbfun), ... %zb_downstream, ... %S0, ...
			func2str(wfun), ... % W0, ...
			func2str(cdfun), ... % cd, ...
			... % Q0, ...
			... %z1_downstream, ...
			omega, ...		% left end
		bc0l_var{1}, ...
		bc0l_val{1}, ...
		bc0l_p{1}, ...
			bcl_var{1}, ...
			bcl_val{1}, ...
			bcl_p{1}(1), ...
			bcl_p{1}(2), ...
			bcl_q{1}(1), ...
			bcl_q{1}(2), ...
			bc2l{:}, ...
		bc0r_var{1}, ...		% right end
		bc0r_val{1}, ...
		bc0r_p{1}, ...
			bcr_var{1}, ...
			bcr_val{1}, ...
			bcr_p{1}(1), ...
			bcr_p{1}(2), ...
			bcr_q{1}(1), ...
			bcr_q{1}(2), ...
			bc2r{:}, ...
			L,	 ...
			opt.nx,	 ...
			opt.xs ...
		);

	% test if simulation was not yet run for the parameter pair
	if (isKey(obj.rt,key) && ~obj.recompute)
		out = obj.rt(key);
	else
		disp(['recomputing ', key]);
		obj.recflag = true;
%
		switch (opt.model_str)
		case {'odeset'}
			bc = struct();
			if (0)
				fzb = @(x) zb_downstream+(Xi(end)-x)*S0;
				bc.z0  = [0 0];
				%fzb(Xi(1))+normal_flow_depth 
				bc.cz1 = [0 z1_downstream]; % [0 1]
				bc.sz1 = [0 0.0];
			else
				fzb = @(x) zb_downstream + x*S0;
				Q0_     = -Q0;
				bc.z0  = [0 0];
				bc.cz1 = [z1_downstream 0]; % [1 0]
				bc.sz1 = [0 0];
			end
			out = rt_quasi_stationary_trigonometric(Xi,W0,Q0_,cd,omega,zbfun,bc,opt);
		case {'wave','swe'}
			x         = linspace(Xi(1),Xi(2))';

			% TODO make RT intelligent to accept scalars instead of functions
			out = River_Tide( ...
				   'fun.zb',      zbfun ...
				 , 'fun.cd',      cdfun ...
				 , 'fun.width',   wfun ...
				 , 'omega',       omega ...
				 , 'opt',         opt ...
				 , 'Xi',          Xi ...
				);

			bc            = out.bc;

			% boundary condition mean component (left end)
			bc(1,1).var   = bc0l_var{1};
			bc(1,1).rhs   = bc0l_val{1};
			bc(1,1).p     = bc0l_p{1};
			% right end
			bc(2,1).var   = bc0r_var{1};
			bc(2,1).rhs   = bc0r_val{1};
			bc(2,1).p     = bc0r_p{1};
			% boundary condition main tidal component
			bc(1,2).var   = bcl_var{1};
			bc(1,2).rhs   = bcl_val{1};
			bc(1,2).p     = bcl_p{1}; 
			bc(1,2).q     = bcl_q{1};
			bc(2,2).var   = bcr_var{1};
			bc(2,2).rhs   = bcr_val{1};
			bc(2,2).p     = bcr_p{1}; 
			bc(2,2).q     = bcr_q{1};
			if (~isempty(bc2l_var))
			% bc of even overtide
				bc(1,3).var   = bc2l_var{1};
				bc(1,3).rhs   = bc2l_val{1};
				bc(1,3).p     = bc2l_p{1}; 
				bc(1,3).q     = bc2l_q{1}; 
			end
			if (~isempty(bc2r_var))
				bc(2,3).var   = bc2r_var{1};
				bc(2,3).rhs   = bc2r_val{1};
				bc(2,3).p     = bc2r_p{1}; 
				bc(2,3).q     = bc2r_q{1}; 
			end

			out.bc = bc;

			% out.init([0,z1_downstream], Q0, Xi);
			% out.init([0,0], Q0, Xi);
			out.init();

			out.solve();

			obj.rt(key) = out;
		otherwise
			error('unimplemented solver');
		end
	end % if ~iskey
end % River_Tide_Map/fun

